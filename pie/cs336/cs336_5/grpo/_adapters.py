from __future__ import annotations

import os
from typing import Any, Callable, Literal

import torch
from torch import Tensor
from torch.utils.data import Dataset
from transformers import PreTrainedTokenizerBase
import json
import re

def run_tokenize_prompt_and_output(
    prompt_strs: list[str],
    output_strs: list[str],
    tokenizer: PreTrainedTokenizerBase,
) -> dict[str, Tensor]:
    """Tokenize the prompt and output strings, and construct a mask that is 1
    for the response tokens and 0 for other tokens (prompt or padding).

    Args:
        prompt_strs: list[str], the prompt strings.
        output_strs: list[str], the output strings.
        tokenizer: PreTrainedTokenizer, the tokenizer to use.

    Returns:
        dict[str, torch.Tensor]:
            "input_ids": torch.Tensor of shape (batch_size, max(prompt_and_output_lens) - 1):
                the tokenized prompt and output strings, with the final token sliced off.
            "labels": torch.Tensor of shape (batch_size, max(prompt_and_output_lens) - 1):
                shifted input_ids (i.e., the input_ids without the first token).
            "response_mask": torch.Tensor of shape (batch_size, max(prompt_and_output_lens) - 1):
                a mask on the response tokens in `labels`.
    """
    assert(len(prompt_strs) == len(output_strs))
    batch_size = len(prompt_strs)

    if tokenizer.eos_token_id is None:
        raise ValueError("No EOS token for this tokenizer.")
    
    prompt_tokenized = tokenizer(prompt_strs, add_special_tokens=False, return_tensors=None)["input_ids"]
    output_tokenized = tokenizer(output_strs, add_special_tokens=False, return_tensors=None)["input_ids"]

    temp = []
    for t1,t2 in zip(prompt_tokenized , output_tokenized):
        temp.append(t1 + t2)
    seq_len = max([len(t) for t in temp])

    result = [t + [tokenizer.eos_token_id] * (seq_len - len(t)) for t in temp]
    result = torch.tensor(result)

    input_ids = result[:,:-1]
    labels = result[:,1:]

    starts = torch.tensor([len(prompt)-1 for prompt in prompt_tokenized]).unsqueeze(1).expand(-1, seq_len - 1)
    ends = torch.tensor([len(t)-1 for t in temp]).unsqueeze(1).expand(-1, seq_len - 1)
    response_mask = torch.arange(seq_len - 1).unsqueeze(0).expand(batch_size, -1)
    response_mask = ((response_mask >= starts) & (response_mask < ends)) * 1
    return {
        "input_ids": input_ids,
        "labels": labels,
        "response_mask": response_mask
    }


def run_compute_group_normalized_rewards(
    reward_fn: Callable,
    rollout_responses: list[str],
    repeated_ground_truths: list[str],
    group_size: int,
    advantage_eps: float,
    normalize_by_std: bool,
) -> tuple[torch.Tensor, dict[str, float]]:
    """
    Compute rewards for each group of rollout responses, 
    normalized by the group size.

    For more on GRPO, see:
        DeepSeekMath: https://arxiv.org/abs/2402.03300
        DeepSeek-R1: https://arxiv.org/abs/2501.12948

    Args:
        reward_fn: Callable[[str, str], dict[str, float]], 
            scores the rollout responses against the ground truths, 
            producing a dict with keys 
            "reward", "format_reward", and "answer_reward".
        rollout_responses: list[str], rollouts from the policy. 
            The length of this list is 
            `rollout_batch_size = n_prompts_per_rollout_batch * group_size`.
        repeated_ground_truths: list[str], the ground truths for the examples. 
            The length of this list is `rollout_batch_size`, 
            because the ground truth for each example is repeated `group_size` times.
        group_size: int, number of rollouts per group.
        advantage_eps: float, epsilon to avoid division by zero
            during group normalization.
        normalize_by_std: bool, whether to normalize the rewards by
            std(rewards).

    Returns:
        tuple[torch.Tensor, torch.Tensor, dict[str, float]]:
            torch.Tensor of shape (rollout_batch_size,): 
                group-normalized rewards for each rollout response.
            torch.Tensor of shape (rollout_batch_size,): 
                raw rewards for each rollout response.
            dict[str, float]: metadata for the rewards of the rollout batch.
                You may choose what you wish to log here
                (some statistics of the rewards, etc.).
    """
    assert len(rollout_responses) == len(repeated_ground_truths)
    raw_rewards = [reward_fn(response,answer)['reward'] for response, answer in zip(rollout_responses, repeated_ground_truths)]
    raw_rewards = torch.tensor(raw_rewards)

    n_prompts_per_rollout_batch = len(rollout_responses) // group_size
    group_normalized_rewards = raw_rewards - raw_rewards.view(n_prompts_per_rollout_batch,-1).mean(dim=-1,keepdim=False).repeat_interleave(repeats=group_size)
    if normalize_by_std:
        std =  raw_rewards.view(n_prompts_per_rollout_batch,-1).std(dim=-1,keepdim=False).repeat_interleave(repeats=group_size) + advantage_eps
        group_normalized_rewards = group_normalized_rewards / std
    
    return [group_normalized_rewards, raw_rewards, {"rewards": raw_rewards}]



def run_compute_entropy(logits: torch.Tensor) -> torch.Tensor:
    """Get the entropy of the logits (i.e., entropy of the final dimension)."""
    log_probs = logits - torch.logsumexp(logits, dim=-1,keepdim=True)
    entropy = - torch.exp(log_probs) * log_probs
    return entropy.sum(dim=-1)


def run_get_response_log_probs(
    model: torch.nn.Module,
    input_ids: torch.Tensor,
    labels: torch.Tensor,
    return_token_entropy: bool,
) -> torch.Tensor:
    """Get the conditional log-probs of the response given the prompt,
        and optionally the entropy of the next token predictions.

    Args:
        model: PreTrainedModel, the model to score.
        input_ids: torch.Tensor of shape (batch_size, sequence_length):
            the tokenized prompt and output.
        labels: torch.Tensor of shape (batch_size, sequence_length):
            shifted input_ids.
        return_token_entropy: bool, whether to return the entropy of the
            next token predictions.

    Returns:
        dict[str, torch.Tensor]:
            "log_probs": torch.Tensor of shape (batch_size, sequence_length):
                the conditional log-probs of the response given the prompt.
                Note that we have not masked out the token indices corresponding
                to the prompt or padding; that is done in the train loop.
            "token_entropy": Optional[torch.Tensor] of shape (batch_size, sequence_length):
                the entropy of the next token predictions. As with the log-probs,
                we have not masked out the token indices corresponding to the prompt
                or padding; that is done in the train loop.
    """
    l = model(input_ids).logits
    log_probs = l - torch.logsumexp(l, dim=-1,keepdim=True)

    b, s = labels.shape

    result = log_probs[torch.arange(b)[:, None], torch.arange(s), labels]

    result_dict = {}
    result_dict["log_probs"] = result
    if (return_token_entropy):
        result_dict["token_entropy"] = run_compute_entropy(l)

    return result_dict


def run_compute_naive_policy_gradient_loss(
    raw_rewards_or_advantages: torch.Tensor,
    policy_log_probs: torch.Tensor,
) -> torch.Tensor:
    """Compute policy gradient loss using either raw rewards or advantages.

    Args:
        raw_rewards_or_advantages: torch.Tensor of shape (batch_size, 1): 
            the raw rewards or advantages for each rollout response.
        policy_log_probs: torch.Tensor of shape (batch_size, sequence_length): 
            the log-probs of the policy.

    Returns:
        torch.Tensor of shape (batch_size, sequence_length): 
            the policy gradient per-token loss.
    """
    return -raw_rewards_or_advantages*policy_log_probs


def run_compute_grpo_clip_loss(
    advantages: torch.Tensor,
    policy_log_probs: torch.Tensor,
    old_log_probs: torch.Tensor,
    cliprange: float,
) -> tuple[torch.Tensor, dict[str, torch.Tensor]]:
    """Compute the GRPO-Clip loss.

    Args:
        advantages: torch.Tensor of shape (batch_size, 1): 
            the advantages for each rollout response.
        policy_log_probs: torch.Tensor of shape (batch_size, sequence_length): 
            the log-probs of the policy.
        old_log_probs: torch.Tensor of shape (batch_size, sequence_length): 
            the log-probs of the old policy.
        cliprange: float, the clip range for the ratio.

    Returns:
        tuple[torch.Tensor, dict[str, torch.Tensor]]:
            torch.Tensor of shape (batch_size, sequence_length): 
                the GRPO-Clip per-token loss.
            dict[str, torch.Tensor]: metadata for the GRPO-Clip loss 
                (used to compute clip fraction).
    """
    # basic check
    # assert not advantages.requires_grad
    # assert not old_log_probs.requires_grad
    # assert policy_log_probs.requires_grad

    ratio = torch.exp(policy_log_probs - old_log_probs)

    result_a = ratio * advantages
    clipped_mask = (ratio < 1 - cliprange) | (ratio > 1 + cliprange)
    result_b = torch.clip(ratio, 1 - cliprange, 1 + cliprange) * advantages
    result = - torch.minimum(result_a, result_b)

    return [result, {"clip_fraction": torch.tensor(clipped_mask.float().mean())}]


def run_compute_policy_gradient_loss(
    policy_log_probs: torch.Tensor,
    loss_type: str,
    raw_rewards: torch.Tensor,
    advantages: torch.Tensor,
    old_log_probs: torch.Tensor,
    cliprange: float,
) -> tuple[torch.Tensor, dict[str, torch.Tensor]]:
    """
    Wrapper that delegates to the appropriate policy gradient loss function above.
    """
    loss = None
    md = None
    match loss_type:
        case "no_baseline":
            loss = run_compute_naive_policy_gradient_loss(raw_rewards, policy_log_probs)
        case "reinforce_with_baseline":
            loss = run_compute_naive_policy_gradient_loss(advantages, policy_log_probs)
        case "grpo_clip":
            loss, md = run_compute_grpo_clip_loss(advantages, policy_log_probs, old_log_probs, cliprange)
        case _:
            raise NotImplementedError
    return loss, md


def run_masked_mean(tensor: torch.Tensor, mask: torch.Tensor, dim: int | None = None) -> torch.Tensor:
    """Compute the mean of the tensor along a dimension,
    considering only the elements with mask value 1.

    Args:
        tensor: torch.Tensor, the tensor to compute the mean of.
        mask: torch.Tensor, the mask. We only take the mean over
            the elements with mask value 1.
        dim: int | None, the dimension to compute the mean along.
            If None, sum over all non-masked elements and average
            by their total count.

    Returns:
        torch.Tensor, the mean of the tensor along the specified
            dimension, considering only the elements with mask value 1.
    """
    valid_tokens = mask.sum(dim=dim)
    return (tensor * mask).sum(dim=dim) / valid_tokens

def run_sft_microbatch_train_step(
    policy_log_probs: torch.Tensor,
    response_mask: torch.Tensor,
    gradient_accumulation_steps: int,
    normalize_constant: int | None = 1.0,
) -> tuple[torch.Tensor, dict[str, torch.Tensor]]:
    """Compute the policy gradient loss and backprop its gradients for a microbatch.
    """
    microbatch_size = policy_log_probs.shape[0]

    token_loss = - policy_log_probs * response_mask
    if (normalize_constant is not None):
        token_loss = token_loss / normalize_constant
    num_tokens = response_mask.sum()
    total_loss = token_loss.sum() / (microbatch_size * gradient_accumulation_steps)
    per_token_loss = total_loss / num_tokens

    total_loss.backward()

    return [total_loss, {"per_token_loss": per_token_loss, "total_loss": total_loss}]

    
def run_grpo_microbatch_train_step(
    policy_log_probs: torch.Tensor,
    response_mask: torch.Tensor,
    gradient_accumulation_steps: int,
    loss_type: Literal["no_baseline", "reinforce_with_baseline", "grpo_clip"],
    raw_rewards: torch.Tensor | None = None,
    advantages: torch.Tensor | None = None,
    old_log_probs: torch.Tensor | None = None,
    cliprange: float | None = None,
) -> tuple[torch.Tensor, dict[str, torch.Tensor]]:
    """Compute the policy gradient loss and backprop its gradients for a microbatch.

    Args:
        policy_log_probs: torch.Tensor of shape (batch_size, sequence_length): 
            the log-probs of the policy.
        response_mask: torch.Tensor of shape (batch_size, sequence_length): 
            the mask for the response.
        gradient_accumulation_steps: int, the number of gradient accumulation steps.
        loss_type: Literal["no_baseline", "reinforce_with_baseline", "grpo_clip"], 
            the type of loss function to use.
        raw_rewards: torch.Tensor | None, the raw rewards for each rollout response.
            Needed for loss_type="no_baseline".
        advantages: torch.Tensor | None, the advantages for each rollout response.
            Needed for loss_type in {"reinforce_with_baseline", "grpo_clip"}.
        old_log_probs: torch.Tensor | None, the log-probs of the old policy.
            Needed for loss_type="grpo_clip".
        cliprange: float | None, the clip range for the ratio. 
            Needed for loss_type="grpo_clip".
        constant_normalize_factor: int | None, provided if we want to sum over 
            the sequence dimension and normalize by this constant factor
            (as in Dr. GRPO).

    Returns:
        tuple[torch.Tensor, dict[str, torch.Tensor]]: 
            the policy gradient loss and its metadata.
    """
    loss, md = run_compute_policy_gradient_loss(policy_log_probs, loss_type, raw_rewards, advantages, old_log_probs, cliprange)
    total_loss = run_masked_mean(loss, response_mask, dim=-1).mean() / gradient_accumulation_steps
    total_loss.backward()
    return total_loss, md


def run_masked_normalize(
    tensor: torch.Tensor,
    mask: torch.Tensor,
    dim: int | None = None,
    normalize_constant: float = 1.0,
) -> torch.Tensor:
    """Sum over a dimension and normalize by a constant,
    considering only the elements with mask value 1.

    Args:
        tensor: torch.Tensor, the tensor to sum and normalize.
        mask: torch.Tensor, the mask. We only consider elements
            with mask value 1.
        dim: int | None, the dimension to sum along before
            normalization. If None, sum over all dimensions.
        normalize_constant: float, the constant to divide by
            for normalization.

    Returns:
        torch.Tensor, the normalized sum, where masked elements
            (mask=0) don't contribute to the sum.
    """
    result = tensor*mask
    return result.sum(dim=dim) / normalize_constant


"""
The below adapters are used in the optional 
RLHF / safety part of the Alignment assignment.
"""


def get_packed_sft_dataset(
    tokenizer: PreTrainedTokenizerBase,
    dataset_path: str | os.PathLike,
    seq_length: int,
    shuffle: bool,
) -> Dataset:
    """
    Given a tokenizer and a path to a dataset with instruction-tuning examples,
    construct a PyTorch Dataset for language modeling. The examples should be
    packed, i.e., all sequences in the dataset are of a constant length (`seq_length`).

    Args:
        tokenizer: transformers.PreTrainedTokenizerBase
            Transformers tokenizer to use in tokenizing and encoding text.
        dataset_path: str
            Path to file with instruction-tuning examples.
        seq_length: int
            Number of tokens to include in each example.
        shuffle: bool
            If true, shuffle the documents before packing them into examples.

    Returns:
        PyTorch Dataset for language modeling. Each example in this dataset is a dictionary of
        with keys "input_ids" and "labels" (both tensors of shape (seq_length, )).
        "input_ids" contains the token IDs for the language modeling inputs, and "labels" contains
        the token IDs for the language modeling labels.
    """
    class SFTDataset(Dataset):
        def __init__(self, tokenizer, dataset_path, seq_length, shuffle):
            if tokenizer.eos_token_id is None or tokenizer.bos_token_id is None:
                raise ValueError("No EOS/BOS token for this tokenizer.")
            self.eos = tokenizer.eos_token_id

            with open("/home/zzx/cs/assignment5-alignment/cs336_alignment/prompts/alpaca_sft.prompt") as f:
                self.prompt_template = f.read()
            self.prompt_template = self.prompt_template.strip() # WTF idk why there is a \n at the end of THE BLOODYYYY FKINGGGGG FILE

            with open(dataset_path, 'r') as f:
                self.dataset = f.readlines()
                if shuffle:
                    import random
                    random.shuffle(self.dataset)

            self.seq_length = seq_length
            
            print("Tokenizing the inputs and adding eos...")
            ids = tokenizer(list(map(self.get_input_string, self.dataset)))["input_ids"]
            entire_input_ids = torch.cat(list(map(self.add_eos_token, ids)),dim=0)

            print("Preparing input_ids and labels...")
            self.total_batches = (entire_input_ids.shape[0] - 1) // self.seq_length
            entire_input_ids = entire_input_ids[: self.total_batches * self.seq_length + 1]
            self.input_ids = entire_input_ids[:-1].view(self.total_batches, -1)
            self.labels =entire_input_ids[1:].view(self.total_batches, -1)
            assert self.input_ids.shape[1] == self.labels.shape[1]            

        def __len__(self):
            return self.total_batches
        def __getitem__(self, idx):
            return {
                "input_ids": self.input_ids[idx],
                "labels": self.labels[idx],
            }
        def get_input_string(self, s):
            data = json.loads(s.strip())
            return self.prompt_template.replace("{response}",data["response"]).replace("{instruction}", data["prompt"])
        def add_eos_token(self, l):
            return torch.tensor(l + [self.eos])
        
    return SFTDataset(tokenizer, dataset_path, seq_length, shuffle)


def run_iterate_batches(
    dataset: Dataset,
    batch_size: int,
    shuffle: bool,
):
    """
    Given a PyTorch Dataset, return an iterable over batches of size `batch_size`.
    Iterating through the returned iterable should constitute one epoch over the Dataset.

    Args:
        dataset: Dataset
            Dataset to emit batches from.
        batch_size: int
            Number of examples to include per batch.
        shuffle: bool
            If true, shuffle examples before batching them.

    Returns:
        Iterable over batches, where each batch has size `batch_size`.
    """
    from torch.utils.data import DataLoader
    return DataLoader(dataset=dataset, batch_size=batch_size, shuffle=shuffle, num_workers=1, drop_last=False)


def run_parse_mmlu_response(
    mmlu_example: dict[str, Any],
    model_output: str,
) -> str | None:
    """
    Given an MMLU example and a model output, parse the model output into a
    predicted option letter (i.e., 'A', 'B', 'C', or 'D'). If the model output
    cannot be parsed into a prediction option letter, return None.

    mmlu_example: dict[str, Any]
        Dictionary with an MMLU example. Contains the following keys:
        - "subject": str with the subject of the question.
        - "question": str with the text of the question.
        - "options": list[str] with the four answer options (in order).
                     The first option refers to letter "A", the second to "B", etc.
        - "answer": str with the option of the correct answer (e.g., "A")
    model_output: str
        str with the model's output to the MMLU example.

    Returns:
        str (one of "A", "B", "C", or "D") if the model output can be parsed into a prediction,
        else None.
    """
    parsed = re.findall(r'[A-D]', model_output)
    if (len(parsed) > 0) and (parsed[0] in ["A","B","C","D"]):
        return parsed[0]
    else:
        return None


def run_parse_gsm8k_response(
    model_output: str,
) -> str | None:
    """
    Given a GSM8K model output, parse the model output into a predicted numeric answer by
    taking the last number that occurs in the output.

    model_output: str
        str with the model's output to a GSM8K example.

    Returns:
        str with the predicted numeric answer if the model output can be parsed into a prediction,
        else None.
    """

    raise NotImplementedError


def run_compute_per_instance_dpo_loss(
    lm: torch.nn.Module,
    lm_ref: torch.nn.Module,
    tokenizer: PreTrainedTokenizerBase,
    beta: float,
    prompt: str,
    response_chosen: str,
    response_rejected: str,
) -> torch.Tensor:
    """
    Given two language models (`lm`, and the "reference model" `lm_ref`),
    their tokenizer, the DPO beta hyperparameter, a prompt and a pair
    of responses to the prompt, computes the value of the DPO loss for this example.

    lm: torch.nn.Module
        Language model being trained.
    lm_ref: torch.nn.Module
        Reference language model.
    tokenizer: PreTrainedTokenizerBase
        Tokenizer for both language models.
    beta: float
        DPO beta hyperparameter.
    prompt: str
        Prompt for this instance of preference pair.
    response_chosen: str
        Preferred response to the prompt.
    response_rejected: str
        Rejected response to the prompt.

    Returns:
        torch.Tensor with the DPO loss for this example.
    """
    raise NotImplementedError
